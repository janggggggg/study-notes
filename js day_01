let runningTotal = 0;   // 총합
let buffer = "0";       // 입력하는숫자나 값을 임시 저장 ,문자열로 해놔야 이어 붙여 저장됨
let previousOperator;   // 이전 연산자

const screen = document.querySelector('.screen');

function buttonClick(value){    // 클릭한거 처리해주는 함수
    if(isNaN(value)){
        handleSymbol(value);    // 숫자 아닐시 플마곱나 이런거
    }else{                              
        handleNumber(value);    // 숫자면 ㅇㅇ
    }
    screen.innerText = buffer;  // screen(0) 부분에 값이 바뀌면 그 값으로 저장
}

function handleSymbol(symbol){
    switch(symbol){
        case 'C':
            buffer = '0';
            runningTotal = 0;
            break;              // C: 초기화버튼 
        case '=':
            if(previousOperator === null){      // 이전 연산자가 없으면 그대로 반환.
                return
            }
            flushOperation(parseInt(buffer));   // buffer에 있는 값을 정수로 변환하여 계산을 실행하는 함수
            previousOperator = null;
            buffer = runningTotal;
            break;
        case '←':
            if(buffer.length ===1){
                buffer = '0';
            }else{
                buffer = buffer.substring(0, buffer.length - 1); // 0번째부터 마지막자른 값만 나옴.
            }
            break;
        case '+':
        case '-':
        case '×':
        case '÷':
            handleMath(symbol);
            break;    
    }
}

// 일단 코드를 직접 짤 정돈 아니여서 코드를 가져와서 한땀한땀 이해하는중.




/////////////////////////////////////////////////////////////////////////////////////////////////////////////



function handleMath(symbol){
    if(buffer === '0'){
        return;
    }

    const intBuffer = parseInt(buffer);

    if(runningTotal === 0){
        runningTotal = intBuffer;   //첫 번째 연산이므로, runningTotal에 현재 숫자(intBuffer)를 저장
    }else{
        flushOperation(intBuffer);  //runningTotal이 0이 아니라면, 즉 이미 숫자를 넣은 상태라면,
    }
    previousOperator = symbol; // 이전연산자를 심볼로 남겨둠.
    buffer = '0';   //연산자가 입력된 후, 새로운 숫자를 입력하기 위해 buffer를 '0'으로 초기화
}

function flushOperation(intBuffer){
    if(previousOperator === '+'){
        runningTotal += intBuffer;
    }else if(previousOperator === '−'){
        runningTotal -= intBuffer;
    }else if(previousOperator === '×'){
        runningTotal *= intBuffer;
    }else if(previousOperator === '÷'){
        runningTotal /= intBuffer;
    }
}

function handleNumber(numberString){  // 계산하기전엔 문자열로 적혀야 되니깐.
    if(buffer === "0"){
        buffer = numberString;  // buffer가 '0'이라면, 새로운 문자열 숫자로 덮어씌움
    }else{
        buffer += numberString; // buffer에 새로운 숫자를 이어붙임
    }
}

function init(){
    document.querySelector('.calc-buttons').addEventListener('click', function(event){
        buttonClick(event.target.innerText);
    })
}

init();     // 초기화 시점 차이: let runningTotal = 0;, let buffer = "0"; 등의 변수
// 는 페이지가 로드되면 즉시 필요합니다. 즉, 이러한 값들은
//  페이지 로드 시 바로 설정되어야 하므로,
//  이벤트 리스너를 설정하는 init() 함수 바깥에서 선언하는 것이 자연스럽습니다.

// 반면, 이벤트 리스너 설정은 사용자가 버튼을 클릭할 때 발생하는 동작이므로,
//  초기화 시점에서 별도로 분리하여 init() 함수로 처리하는 것이 적합합니다.


// 계산기 코드를 이해는 다 했지만 혼자만들어보는 과정이 필요할듯싶다.



/////////////////////////////////////////////////////////////////////////////////////////////////////////////




// 계산기 코드를 혼자서 다시 처음부터 짜보는데 함수에 이름을 설정하는것과 어떤 코드를 먼저 써나가야 할지가 어려웠다 . 
// 첫번째 다시 만들땐 막힐때마다 다시 보면서 다 짰고 두번째로 다시 짜보는중
// 특히나 어려웠던게 현재값을 숫자로 변환하여 계산하고 = 으로 출력하는 과정까지가 어지러웠다. 그냥 계속 왜 이런구조여야 하는지 찾아보며 깨닫는중.

let runningTotal = 0;
let previousOperator;
let buffer = '0';



function init(){
    document.querySelector('.calc-buttons').addEventListener('click', function(event){
        buttonClick(event.target.innerText);
    })
}

const screen = document.querySelector('.screen')

function buttonClick(value){
    if(isNaN(value)){
        handleSymbol(value);
    }else{
        handleNumber(value);
    }
    screen.innerText = buffer;
}

function handleNumber(numberString){
    if(buffer === '0'){
        buffer = numberString;
    }else{
        buffer += numberString;
    }
}

function handleSymbol(symbol){
    switch(symbol){
        case 'C':
            runningTotal = 0;
            buffer = '0';
            break;
        case '=':
            if(previousOperator === null){
                return;
            }
            flushOperation(parseInt(buffer));
            previousOperator = null;
            buffer = '0';
    }
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////



// 달력을 구현하려고 달력 코드를 보는데 답이없어서 달력관련 코드들을 찾아 공부중.


let date = new Date(2012,1,20,3,12);

alert(date);

function getWeekDay(date) {
    let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
  
    return days[date.getDay()];
  }
  
  let date = new Date(2014, 0, 3); // 2014년 1월 3일
  alert( getWeekDay(date) ); // FR

function getLocalDay(date){
    let day = date.getDay();
    if(day === 0){
        day = 7;
    }
    return day;
}

function getDateAgo(date, days) {
    date.setDate(date.getDate() - days);
    return date.getDate();
  }

// https://ko.javascript.info/date에서 공부하고 나온 문제 풀어보는데 아직 너무 어렵게 느껴짐;;




/////////////////////////////////////////////////////////////////////////////////////////////////////////////




//  date를 기준으로 days일 전 '일’을 반환하는 함수
function getDateAgo(date, days){
    date.setDate(date.getDay() - days);
    return date.getDay();
}

//특정 달의 마지막 일을 반환하는 함수
function getLastDayOfMonth(year, month){
    let date = new Date(year, month + 1, 0);
    return date.getDate();
}

//오늘 하루가 시작된 이후 몇 초나 지났는지 반환하는 함수
function getSecondsToday(){
    let now = new Date();
    let today = new Date(now.getFullYear(),now.getMonth(),now.getDate());

    let diff = now - today;
    return Math.round(diff / 1000); // Math.round: 주어진 숫자를 가장 가까운 정수로 반올림해줌
}                                   // diff / 1000: 밀리초를 초로 변환

alert (getSecondsToday());

//오늘 하루 경과 시간, 분, 초를 초로 변환하는 함수 
function getSecondsTodayy(){
    let d = new Date();

    return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds;
}

//오늘 하루가 끝날 때까지 남은 초를 반환해주는 함수 
//오늘 하루가 끝날 때까지 남은 밀리초를 구하려면 '내일 00시 00분 00초’에서 현재 날짜를 빼면 됩니다.
function getSecondsToTomorrow(){
    let now = new Date();

    // 내일 날짜
    let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);

    let diff = tomorrow - now; // 차이(ms)
    return Math.round(diff / 1000); // 초로 변환

}

// 주어진 date 값에 대해 현재 시간과의 차이를 계산하고,
// 그 차이에 따라 적절한 형식으로 날짜를 출력하는 함수

// 5분 전에 작성된 댓글 , 유튜브 "5분 전" 이런거
function formatDate(date) {
    
    // "현재"  
    let diff = new Date() - date; // 차이(ms)

    if (diff < 1000) { // 차이가 1초 미만이라면
        return '현재';
      }

    // "n초 전"  
    let sec = Math.floor(diff / 1000); // 차이를 초로 변환     floor:내림 처리

    if (sec < 60) {
        return sec + '초 전';
      }

    // "n분 전"
    let min = Math.floor(diff / 60000); // 차이를 분으로 변환      1000 * 60

    if (min < 60) {
        return min + '분 전';
      }

    // 어제를 나타내는 날짜를 "일.월.연 시:분" 포맷으로 출력
    let d = date;
    d = [
      '0' + d.getDate(),
      '0' + (d.getMonth() + 1),
      '' + d.getFullYear(),
      '0' + d.getHours(),
      '0' + d.getMinutes()
    ].map(item => item.slice(-2)); // 모든 컴포넌트의 마지막 숫자 2개를 가져옴

    // .map(): 배열의 각 요소에 대해 지정된 작업을 수행하여 새로운 배열을 반환하는 메서드
    // slice(-2): 각 컴포넌트의 마지막 두 문자를 잘라내는 역할

    return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
    
    // 1,2,3 번째 배열 사이에 . + 3번째 이후로 잘린 배열 사이에 :
    // xx.xx.xx xx:xx

}


// 전반적인 문법은 이해가 가는데 활용할때 헷갈리는 점이 좀 있다. 내일은 달력에 쓰인 코드를 이해해봐야겠다.
